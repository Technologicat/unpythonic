#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Generic bootstrapper to run a Python program with MacroPy3 enabled.

Eliminates the need for a per-project bootstrapper."""

import imp  # TODO: once upgraded to Python 3.5+, replace the deprecated imp
import importlib
import argparse
import sys
import macropy.activate

__version__ = '1.2.0'

def main():
    """Handle command-line arguments and run the specified main program."""
    parser = argparse.ArgumentParser(description="""Generic MacroPy3 bootstrapper: run a Python program with MacroPy3 enabled.""",
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument( '-v', '--version', action='version', version=('%(prog)s-bootstrapper ' + __version__) )
    parser.add_argument(dest='smodule', nargs='?', default=None, type=str, metavar='module',
                        help='The module name of the main program to run, pretending its __name__ == "__main__". Alternative to "-m module."')
    parser.add_argument('-m', '--module', dest='module', default=None, type=str, metavar='module',
                        help='The module name of the main program to run, by importing it normally and calling the specified entrypoint. Alternative to the positional module name.')
    parser.add_argument('-e', '--entrypoint', dest='entrypoint', default=None, type=str, metavar='func',
                        help='With -m: specify the entrypoint in the module. If not given, main() and test() are tried, in that order.' )
    parser.add_argument('-d', '--debug', dest='debug', action="store_true", default=False,
                        help='Enable MacroPy logging.')
    opts = parser.parse_args()

    if not opts.smodule and not opts.module:
        parser.print_help()
        sys.exit(0)
        raise ValueError("Please specify a module (either positionally or with -m).")
    if opts.module and opts.smodule:
        raise ValueError("Please specify just one module (either positionally or with -m, not both).")

    if opts.debug:
        import macropy.logging

    if opts.smodule:
        # FIXME: this requires __init__.py to be present at each level of a dotted path (maybe imp does?)
        #
        # Import the target module, but pretend its name is "__main__".
        #
        # We must import so that macros get expanded, so we can't use
        # runpy.run_module here (which just execs without importing).
        #
        # This allows us to have the same semantics as "python3 -m some.module".
        #
        # The price is the target module can't use relative imports
        # (precisely because its name is now "__main__").
        #
        # TODO: once upgraded to Python 3.5+, replace the deprecated imp
        #   https://stackoverflow.com/questions/6114251/how-to-make-name-main-when-running-module/6114411#6114411
        #   https://docs.python.org/3/library/imp.html#imp.find_module
        #   https://docs.python.org/3/library/imp.html#imp.load_module
        #   https://docs.python.org/3/library/importlib.html#importlib.util.find_spec         (Python 3.4+)
        #   https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec  (Python 3.5+)
        def finder(dotted_modname, acc=[], path=None):
            print(path, dotted_modname)
            head, sep, tail = dotted_modname.partition('.')
            spec = imp.find_module(head, path)
            modname = ".".join(acc + [head])
            if tail:
                mod = imp.load_module(modname, *spec)
                return finder(tail, acc=(acc + [head]), path=mod.__path__)
            return spec
        spec = finder(opts.smodule)
        mod = imp.load_module("__main__", *spec)

    else:
        entrypoints = (opts.entrypoint,) if opts.entrypoint else ("main", "test")
        mod = importlib.import_module(opts.module)  # macros are expanded at import time.
        defined_names = dir(mod)
        for candidate in entrypoints:
            if candidate in defined_names:
                entrypoint = getattr(mod, candidate)
                if callable(entrypoint):
                    sys.exit(entrypoint())
        raise ValueError("No entrypoint found in module '{}', tried {}. Does it have a main program?".format(opts.module, entrypoints))

if __name__ == '__main__':
    main()
