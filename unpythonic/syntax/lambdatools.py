# -*- coding: utf-8 -*-
"""Lambdas with multiple expressions, local variables, and a name."""

from ast import Lambda, List, Name, Assign, With, withitem, Subscript, Call

from macropy.core.quotes import macros, u, ast_literal
from macropy.core.hquotes import macros, hq
from macropy.core.walkers import Walker
from macropy.quick_lambda import f, _  # _ for re-export only

from ..dynassign import dyn
from ..misc import namelambda

from .letdo import do
from .util import is_decorated_lambda, isx, make_isxpred

def multilambda(block_body):
    @Walker
    def transform(tree, *, stop, **kw):
        if type(tree) is not Lambda or type(tree.body) is not List:
            return tree
        bodys = tree.body
        # bracket magic:
        # - stop() to prevent recursing to the implicit lambdas generated
        #   by the "do" we are inserting here
        #   - for each item, "do" internally inserts a lambda to delay execution,
        #     as well as to bind the environment
        #   - we must do() instead of hq[do[...]] for pickling reasons
        # - but recurse manually into each *do item*; these are explicit
        #   user-provided code so we should transform them
        stop()
        bodys = transform.recurse(bodys)
        tree.body = do(bodys)  # insert the do, with the implicit lambdas
        return tree
    # multilambda should expand first before any let[], do[] et al. that happen
    # to be inside the block, to avoid misinterpreting implicit lambdas
    # generated by those constructs.
    yield transform.recurse(block_body)

def namedlambda(block_body):
    def issingleassign(tree):
        return type(tree) is Assign and len(tree.targets) == 1 and type(tree.targets[0]) is Name

    iscurry = make_isxpred("curry")
    def iscurrywithfinallambda(tree):  # detect a manual curry
        if not (type(tree) is Call and isx(tree.func, iscurry) and tree.args):
            return False
        return type(tree.args[-1]) is Lambda
    # Detect an autocurry from an already expanded "with curry".
    # CAUTION: These must match what unpythonic.syntax.curry.curry uses in its output.
    iscurrycall = make_isxpred("currycall")
    iscurryf = make_isxpred("curryf")
    def isautocurrywithfinallambda(tree):
        if not (type(tree) is Call and isx(tree.func, iscurrycall) and tree.args and \
                type(tree.args[-1]) is Call and isx(tree.args[-1].func, iscurryf)):
            return False
        return type(tree.args[-1].args[-1]) is Lambda

    @Walker
    def transform(tree, *, stop, **kw):
        if issingleassign(tree):
            myname = tree.targets[0].id
            # for decorated lambdas, match any chain of one-argument calls.
            if type(tree.value) is Lambda or \
               is_decorated_lambda(tree.value, mode="any") or \
               iscurrywithfinallambda(tree.value):
                stop()
                thelambda = tree.value
                tree.value = hq[namelambda(u[myname])(ast_literal[thelambda])]
            elif isautocurrywithfinallambda(tree.value):
                stop()
                thelambda = tree.value.args[-1].args[-1]
                tree.value.args[-1].args[-1] = hq[namelambda(u[myname])(ast_literal[thelambda])]
        return tree

    new_block_body = [transform.recurse(stmt) for stmt in block_body]

#    # TODO: this syntax doesn't work due to missing line numbers?
#    with q as wrapped:  # name lambdas also in env
#        with dyn.let(env_namedlambda=True):
#            ast_literal[newtree]
#    return wrapped

    # name lambdas also in env (enabled for the dynamic extent of the block)
    item = hq[dyn.let(env_namedlambda=True)]
    wrapped = With(items=[withitem(context_expr=item, optional_vars=None)],
                   body=new_block_body)
    return [wrapped]

def quicklambda(block_body):
    def isquicklambda(tree):
        return type(tree) is Subscript and type(tree.value) is Name and tree.value.id == "f"
    @Walker
    def transform(tree, **kw):
        if isquicklambda(tree):
            return f.transform(tree.slice.value)
        return tree
    new_block_body = [transform.recurse(stmt) for stmt in block_body]
    yield new_block_body
